<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java安全的学习与思考</title>
      <link href="/2022/07/22/java%E5%AE%89%E5%85%A8%E7%9A%84%E5%AD%A6%E4%B9%A0-%E6%80%9D%E8%80%83/"/>
      <url>/2022/07/22/java%E5%AE%89%E5%85%A8%E7%9A%84%E5%AD%A6%E4%B9%A0-%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是通过P牛的Java安全漫谈的顺序来进行的整理和理解的 根据Java安全漫谈的内容来进行理解和学习的</p><p>当然只是我本人的理解，要想来点纯正的味就还是去P牛的知识星球看吧</p><p><a href="https://wx.zsxq.com/dweb2/index/group/2212251881">P牛知识星球</a></p></blockquote><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>p牛的安全漫谈里面有一句话 <mark class="hl-label blue">java安全可以从反序列化漏洞开始，而反序列化漏洞又是从反射开始说起。</mark> </p><p>所以要想学习java安全，需要先从反射开始学起。</p><p><strong>对象可以通过反射来获取它的类，类可以通过反射拿到所有的方法，包括私有方法</strong> </p><p>在java中有三种方式来获取一个</p><mark class="hl-label Class.forName">obj.getClass()</mark>  这三种方法，最后一种其实不算是反射，另外两种，一种是通过实例的obj来获取类，一种是知道类的名字来获取类<blockquote><p>使用反射可以合理的绕过沙盒</p></blockquote><p>比如在一个情景下，只有Integer类型的数字，那么怎么调用Runtime类？P牛给了一个例子（伪代码）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数字.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br></pre></td></tr></table></figure><p>这就通过了获取数字的类，来通过 <strong>forName</strong> 方法调用 <strong>Runtime类对象</strong></p><h3 id="关于forName"><a href="#关于forName" class="headerlink" title="关于forName"></a>关于forName</h3><p>forName除了我们上面见到的通过类名字调用类的方法以外还有一种</p><mark class="hl-label name,">forName(String</mark>  当第二个参数等于true的时候和上面讲的forName是一样的<p>第一个参数是类名 第二个参数是否初始化 第三个参数是类加载器 类加载器的作用是告诉JVM如何加载这个类</p><p> 可以通过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br></pre></td></tr></table></figure><p>来通过类加载器获取到类对象</p><h3 id="无参构造函数的利用"><a href="#无参构造函数的利用" class="headerlink" title="无参构造函数的利用"></a>无参构造函数的利用</h3><blockquote><p>除了系统类 想要引用其他类需要import</p><p>但是 forName就不需要，可以加载任意类</p></blockquote><mark class="hl-label blue">class.newInstance()</mark> 可以调用类中的无参构造函数 但是有些情况是无法使用的<ul><li>因为可能使用的类没有无参构造函数</li><li>构造函数是私有的（单例情况</li></ul><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220722113313745.png" alt="image-20220722113313745"></p><p>面对单例模式的时候，通过getMethod和invoke还是可以成功的弹出计算机的</p><blockquote><p>getMethod是通过反射获取一个类特定的公有方法</p><p>invoke是执行方法 正常的执行方法是 A.方法(1,2,3..)在反射中是 方法.invoke(1,2,3…)</p></blockquote><p>拆开来是这样的</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220722120008472.png" alt="image-20220722120008472"></p><h3 id="关于getConstructor"><a href="#关于getConstructor" class="headerlink" title="关于getConstructor"></a>关于getConstructor</h3><p>在无参构造函数中，可以发现如果一个类没有无参构造函数也不是单例模式或者构造方法是私有方法，就无法成功的反射</p><p><strong>这里引入的新反射方法就可以很好的解决上面的问题</strong></p><p>getConstructor的参数是构造函数列表类型</p><p>在获取到构造函数之后 可以使用newInstance来执行</p><p>P牛在这里将了除了Runtime外的另外一种执行命令的方式ProcessBuilder</p><p>这边通过其构造函数来调用star执行命令</p><blockquote><p>在这里普及一下 ProcessBuilder类和Runtime类的一些区别，就是Runtime类执行脚本的时候会弹出一个cmd界面 但是ProcessBuilder不会 它可以在 <strong>后台</strong> 运行</p></blockquote><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220722153544429.png" alt="image-20220722153544429"></p><p>在这里用到了强转，因为clazz是没有类型的，所以在这里直接强转一个类型，然后后面调用方法。</p><p>但是有的时候可能会不能使用强转 所以需要</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220722154218017.png" alt="image-20220722154218017"></p><p>通过 <strong>getMethod</strong> 方法来获取到star方法</p><p>ProcessBuilder有两种构造函数</p><ul><li>public ProcessBuilder(List<String> command)</li><li>public ProcessBuilder(String… command)</li></ul><p>前面展示的是第一种方法的调用</p><p>而第二种涉及java中的可变长参数 可以理解为数组</p><p>那么按照一样的思路写出来的payload因为newInstance和ProcessBuilder都接收的可变长参数，两者叠加为一个二维数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">((ProcessBuilder)</span><br><span class="line">clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;&#125;)).start();</span><br></pre></td></tr></table></figure><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220722160714949.png" alt="image-20220722160714949"></p><p>不同强类型转化的话就是这样的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz =Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;&#125; ));</span><br></pre></td></tr></table></figure><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220722160814866.png" alt="image-20220722160814866"></p><p>一样的思路</p><mark class="hl-label blue">但是现在只是解决了无参构造的问题，如果方法是私有的，那么应该怎么解决？</mark> <h3 id="关于getDeclared"><a href="#关于getDeclared" class="headerlink" title="关于getDeclared"></a>关于getDeclared</h3><p>与前面讲到的几种方法相比，有区别的地方是</p><ul><li>getMethod是获取的所有的公共方法</li><li>getDeclared获取的是类中声明的方法，公共方法和私有方法都可以获取</li></ul><p>在这里用Runtime这个类写一个payload</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz =Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; m = clazz.getDeclaredConstructor();</span><br><span class="line">m.setAccessible(<span class="literal">true</span>); <span class="comment">//这是必须的，在获取到私有方法后需要用这个方法来修改作用域</span></span><br><span class="line">clazz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class).invoke(m.newInstance(),<span class="string">&quot;calc.exe&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="关于反射"><a href="#关于反射" class="headerlink" title="关于反射"></a>关于反射</h3><p>其实java的反射机制 体现的就是一个 <strong>动态</strong> 的特点，只要知道了这个类的名称，就可以获取到这个类所有的属性和方法 包括了 <strong>私有方法</strong>。</p><h2 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h2><blockquote><p>RMI是让java虚拟机上的对象调用另外一个java虚拟机对象上的方法 而且是java独有的一种机制</p></blockquote><h3 id="关于RMI的流程"><a href="#关于RMI的流程" class="headerlink" title="关于RMI的流程"></a>关于RMI的流程</h3><p>平时我们调用方法是这样的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">object1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>();</span><br><span class="line">object1.Method();</span><br></pre></td></tr></table></figure><p>但是如果object1在JVM1上，但是程序运行在JVM2上</p><p>这样如果想访问object1的方法，就需要调用RMI</p><p>RMI主要有三个部分</p><ul><li>RMI registry</li><li>RMI client</li><li>RMI server</li></ul><p>但是其实还涉及到了Stub Skeleton RPL，但是这里不讲这些也可以理解，可以去网上看看更详细的资料</p><p>对服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloInterface</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    &#125; <span class="comment">//继承Remote的接口 定义函数hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">HelloInterface</span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">HelloImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;欢迎来到黑暗米奇妙妙屋&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;┗|｀O′|┛ 嗷~~&quot;</span>;</span><br><span class="line">        &#125; <span class="comment">//实现接口的类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HelloImpl</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloImpl</span>();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);   Naming.rebind(<span class="string">&quot;rmi://127.0.0.1:1099/hello&quot;</span>,hello);</span><br><span class="line">    &#125;<span class="comment">//创建registry 将类的实例化绑定到一个地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RMIServer</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        RMIServer.<span class="type">HelloInterface</span> <span class="variable">hello</span> <span class="operator">=</span> (RMIServer.HelloInterface)</span><br><span class="line">               Naming.lookup(<span class="string">&quot;rmi://192.168.0.111:1099/hello&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> hello.hello();</span><br><span class="line">        System.out.println( ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Naming.lookup 在registry找到名字是hello的对象，然后就跟平时的使用一样。</p><p>启动客户端和服务端可以发现</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220725110959469.png" alt="image-20220725110959469"></p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220725111022141.png" alt="image-20220725111022141"></p><p>成功的调用到了 <strong>hello</strong> 函数</p><p>大概的流程就是这样</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/v2-6e06c5b9bbc9f60796e5d60ebd931eaf_720w.jpg" alt="img"></p><p>在上面 RMI server的代码中</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220725112239832.png" alt="image-20220725112239832"></p><p>可以换为</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220725112300147.png" alt="image-20220725112300147"></p><p>得到的结果是一样的，总的来说就是先创建并且运行RMI registry，然后再将HelloImpl对象绑定在hello上</p><h3 id="关于如何攻击RMI"><a href="#关于如何攻击RMI" class="headerlink" title="关于如何攻击RMI"></a>关于如何攻击RMI</h3><p>P牛提出了两个问题</p><blockquote><ul><li>如果能访问RMI registry的服务 如何利用？</li><li>如果RMI client中的Naming.lookup的第一个参数可控，如何利用？</li></ul></blockquote><p>首先 Java对远程访问RMI registry有限制</p><p>只有是本地访问的时候才可以调用下面几种方法</p><blockquote><ul><li>rebind</li><li>bind</li><li>unbind</li></ul></blockquote><p>但是list和lookup是可以远程调用的</p><p>list可以列出目标上绑定的所有对象</p><p>lookup可以获得某个远程对象</p><p><del>那么这里就可以通过写一些工具来对危险的方法进行探测</del></p><p>Nmap什么的还有Github上面一堆类似的项目 没啥意义</p><h3 id="关于codebase"><a href="#关于codebase" class="headerlink" title="关于codebase"></a>关于codebase</h3><p>codebase可以理解为我们平时看到的本地路径</p><p>会告诉JVM应该去哪个地方寻找类</p><p>比如 指定 codebase &#x3D; <a href="http://2323bb.com/">http://2323bb.com</a></p><p>然后需要加载 org.h3rrr.example.Example类</p><p>那么JVM会下载  <a href="http://2323bb.com/org/h3rrr/example/Example.class">http://2323bb.com/org/h3rrr/example/Example.class</a> 文件</p><p>如果在RMI流程中没有在本地找到需要的类就会加载codebase中的类</p><blockquote><p>那么就可以通过控制codebase来进行rce</p></blockquote><p>但是要满足上述条件需要</p><ul><li>安全配置SecurityManager</li><li>Java版本低 </li><li>设置了java.rmi.server.useCodebaseOnly&#x3D;false</li></ul><p><del><strong>那么如何通过codebase来进行利用呢？</strong> P牛在这里给了一个实例，来试一下</del></p><h3 id="关于攻击RMI"><a href="#关于攻击RMI" class="headerlink" title="关于攻击RMI"></a>关于攻击RMI</h3><blockquote><p>因为内容太多了 会一直进行更进学习的 慢慢更</p></blockquote><p>因为P牛其实在RMI讲的攻击算是只讲了一些，所以在其他地方查了一下相关的资料，准备好好的写一下RMI</p><p><a href="https://xz.aliyun.com/t/7930#toc-0">先知社区RMI攻击方式总结</a></p><p><a href="https://www.anquanke.com/post/id/263726#h2-3">同样是RMI攻击方式的总结，但是更好懂一点</a></p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/20200701101308-6810e0aa-bb40-1.png" alt="img"></p><p>大佬算是总结的很详细了，这个是大纲，差不多能看一下其实对RMI的攻击方法还是很多的</p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><blockquote><p>在日常的CTF比赛中也经常出现反序列化的题目</p><p>虽然大部分都是PHP的反序列化</p></blockquote><p>Java和PHP的反序列化不一样的地方就是 Java可以对序列化数据中插入一些自定义的数据，在反序列化的时候能够通过 <strong>readObject</strong> 进行读取</p><p>反序列化中 <strong>writeObject</strong> 和 <strong>readObject</strong> 是十分 重要的两个函数</p><blockquote><p>这里有一个很经典的Java反序列化工具</p><p><a href="https://github.com/frohoff/ysoserial">ysoserial</a></p></blockquote><h3 id="关于URLDNS"><a href="#关于URLDNS" class="headerlink" title="关于URLDNS"></a>关于URLDNS</h3><p>P牛在这里说了从CC链开始学习Java反序列化是十分困难的</p><p>确实，我一开始也是从CC链入手，但是后面发现越来越看不懂，所以还是从URLDNS开始入手吧！</p><blockquote><p>那么根据ysoserial的payload来看一下URLDNS这个链子</p></blockquote><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726102228536.png" alt="image-20220726102228536"></p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726102252919.png" alt="image-20220726102252919"></p><p>可以看到HashMap，跟进一下</p><blockquote><p>因为之前说了触发反序列化的方法是 readObject，所以直接看到 HashMap -&gt; readObject()</p></blockquote><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726102523097.png" alt="image-20220726102523097"></p><p>可以看到这里对key进行了hash计算，跟进一下</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726102649202.png" alt="image-20220726102649202"></p><p>这里调用了key的hashCode方法，在这里的key是URL，所以跟进一下 java.net.URL的hashCode方法</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726102930545.png" alt="image-20220726102930545"></p><p>可以看到当hashCode为-1的时候会触发 <strong>handler.hashCode</strong> 跟进一下</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726103152356.png" alt="image-20220726103152356"></p><p>这里的handler是  URLStreamHandler 的对象 跟进一下</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726103703041.png" alt="image-20220726103703041"></p><p>发现了 <strong>getHostAddress</strong> 继续跟进一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (u.hostAddress != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> u.hostAddress;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> u.getHost();</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="literal">null</span> || host.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            u.hostAddress = InetAddress.getByName(host);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException se) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u.hostAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到触发了getByName()</p><p>所以整个链子的过程是</p><ol><li>HashMap-&gt;readObject()</li><li>HashMap-&gt;hash()</li><li>URL-&gt;hashCode()</li><li>URLStreamHandler-&gt;hashCode()</li><li>URLStreamHandler-&gt;getHostAddress()</li><li>InetAddress-&gt;getByName()</li></ol><p>根据这个链子来写一个EXP</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先鸽一下 JDK版本太高了 写了跑不起我超</span><br></pre></td></tr></table></figure><h3 id="关于CommonCollections"><a href="#关于CommonCollections" class="headerlink" title="关于CommonCollections"></a>关于CommonCollections</h3><blockquote><p>躲不掉的CC链</p></blockquote><p>在这里P牛给了一个他简化的CC1的链子demo，然后在这个demo中有几个重要的 <strong>接口</strong> 和 <strong>类</strong> </p><p>{ % label Transformer blue %}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TransformedMap转换Map新元素的时候会调用transform方法，类似于调用一个“回调函数”，参数是原始的对象</p><p>{ % label ConstantTransformer blue %}</p><p>是实现Transformer接口的一个类，就是在构造函数的时候传入一个对象 在transform方法将这个对象返回</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn&#123;</span></span><br><span class="line"><span class="params"> <span class="built_in">super</span>()</span>;</span><br><span class="line"> iConstant = constantToReturn; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> iConstant;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>作用就是包装一个对象，在执行回调的时候返回这个对象性，方便进行下一步的操作</p><p>{ % label InvokerTransformer red %}</p><p>也是实现Transformer接口的一个类，可以执行任意方法</p><p>是 <strong>反序列化能够执行任意代码的关键</strong></p><p>在实例化的时候需要传入三个参数</p><ul><li>执行的方法名字</li><li>函数的参数列表的参数类型</li><li>传给这个函数的参数列表</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line"> <span class="built_in">super</span>();</span><br><span class="line"> iMethodName = methodName;</span><br><span class="line"> iParamTypes = paramTypes;</span><br><span class="line"> iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面回调的transform方法，就是执行input对象的methodName</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line"> <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line"> <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> +</span><br><span class="line">iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> +</span><br><span class="line">iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> +</span><br><span class="line">iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>{ % label ChainedTransformer blue %}</p><p>也也也是实现了Transformer接口的一个类</p><p>可以将 内部多个 Transformer串联在一起 前一个回调的返回结果作为后一个回调的参数传入</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726152229772.png" alt="image-20220726152229772"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> &#123;</span><br><span class="line"> <span class="built_in">super</span>();</span><br><span class="line"> iTransformers = transformers; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line"> object = iTransformers[i].transform(object);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> object; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>{ % label TransformedMap blue %}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, keyTransformer,valueTransformer);</span><br></pre></td></tr></table></figure><p>然后来看一下P牛给的代码</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726153010072.png" alt="image-20220726153010072"></p><p>在前面创建了一个transformers，这里面包括了两个Transformer</p><ul><li>ConstantTransformer</li></ul><p>我们在上面才说道，ConstantTransformer的作用就是传入一个对象，在这里我们获取Runtime.getRuntime</p><ul><li>InvokerTransformer</li></ul><p>上面说过这个是 <strong>反序列化执行代码</strong> 的关键！！！在这里面写的是执行 弹计算器的操作 第一个参数写的exec是执行的方法名字 第二个是String的类型，就是exec的参数类型 第三个是传入给这个函数的参数，也就是calc.exe</p><p>然后利用</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726153618011.png" alt="image-20220726153618011"></p><p>将这一系列的 transformer串起来了 根据上面那个流程图来理解一下 但是这些只是一系列的回调，需要包innerMap</p><p>所以用TransformedMap的decorate方法</p><p>通过向Map中放入新的元素来触发回调</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726154859030.png" alt="image-20220726154859030"></p><h3 id="关于TransformedMap"><a href="#关于TransformedMap" class="headerlink" title="关于TransformedMap"></a>关于TransformedMap</h3><blockquote><p>上面那个只能算是一个demo，还不算POC</p><p>md配环境太折磨了，就跟着P牛走一遍，我是不想配这个玩意了</p></blockquote><p>在demo中，通过向Map中加入一个新的元素来触发回调</p><p>但是在实际的反序列化的时候，需要找到一个类，类似于readObject有写入的操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memberValue.setValue(<span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>( value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember( annotationType.members().get(name)));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map.Entry&lt;String,Object&gt;memberValue:memberValues.entrySet()</span><br></pre></td></tr></table></figure><p>主要的逻辑就是这两部分</p><p>在这里的memberValues就是反序列化后得到的Map 然后在后面调用了setValue来设置值，这样就可以触发TransformedMap里面的Transform执行恶意代码</p><p>所以POC需要创建AnnotationInvocationHandler的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,Map.class); construct.setAccessible(<span class="literal">true</span>); </span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> construct.newInstance(Retention.class, outerMap);</span><br></pre></td></tr></table></figure><p>可以看到这里通过了反射的方法来调用AnnotationInvocationHandler的构造方法</p><blockquote><p>是因为sun.reflect.annotation.AnnotationInvocationHandler是JDK内部类，不能直接new来实例化</p></blockquote><p>而AnnotationInvocationHandler的构造函数有两个参数，一个是Annotation类，另外一个是前面的Map</p><blockquote><p>在这里P牛问了什么是Annotation类 为什么要使用Retention.class？</p><p>在这里我理解为：Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明</p><ul><li>@Target</li><li>@Retention,</li><li>@Documented,</li><li>@Inherited</li></ul><p>所以是 Retention.class 不知道对不对</p></blockquote><p>前面构造了AnnotationInvocationHandler的对象，所以需要将这个对象序列化</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727093140160.png" alt="image-20220727093140160"></p><p>然后跟着P牛的代码敲了一下 在之前那个demo下面加了一些东西</p><p>运行发现报错</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727093227496.png" alt="image-20220727093227496"></p><p>是因为 不是所有的对象都支持序列化，<strong>待序列化对象和它全部的内部属性对象都必须要实现 java.io.Serializable接口</strong> </p><p>是因为在之前那个demo中传给ConstantTransformer的Runtime.getRuntime()，Runtime类是没有实现java.io.Serializable接口的，所以不能被 <strong>序列化</strong></p><p>而通过反射可以避免这个问题</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727094132662.png" alt="image-20220727094132662"></p><blockquote><p>我只能说 Java安全…博大精深 Transformer恐怖如斯</p></blockquote><p>因为将Runtime.getRuntime()换成了Runtime.class</p><p>因为前者是 Runtime的对象 后者是 Class对象</p><p>Class类是实现了java.io.Serializable接口的，所以可以序列化 再次运行就可以发现没有报错了 但是还是没有计算器弹出来</p><p>那是因为在readObject里面有一个逻辑判断，当var7不为null的时候才可以触发这个漏洞</p><p>关于如何解决这个问题 P牛也没细说 直接给了解决方案</p><ul><li>AnnotationInvocationHandler 构造函数的第一个参数必须要是Annotation的子类，并且必须要包含至少一个方法 在这里假设方法名是A</li><li>那么TransformedMap.decorate修饰的Map中必须有一个key为X的元素</li></ul><p>所以之前为啥要用Retention.class也解决了，因为有一个方法是value，再往Map里面放一个value的key</p><p>按照道理来说，应该是成功的弹出计算器了</p><p>但是！因为我们的JDK版本太高了，所以会没办法触发</p><p>只有在 8u71以前的版本才可以触发这个版本 因为官方修改了readObject函数 我的评价是寄！昨天配了很久的环境都不对劲，这里就不换环境了，差不多理解一下就行了</p><blockquote><p>高版本和低版本的readObjetc区别就是 没有使用反序列化得到的Map对象，是新建了一个LinkedHashMap对象 后面的操作都是基于LinkedHashMap这个新的对象进行操作了，所以构造的针对Map的操作就没有用了 SAD！！！</p></blockquote><p>在ysoserial中我们可以发现它是利用了LazyMap而不是TransformedMap</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727095956005.png" alt="image-20220727095956005"></p><h3 id="关于LazyMap"><a href="#关于LazyMap" class="headerlink" title="关于LazyMap"></a>关于LazyMap</h3><p>那么那么LazyMap是什么捏？</p><blockquote><p>与TransformedMap类似 来自于Common-Collections库</p><p>继承AbstractMapDecorator</p></blockquote><p>LazyMap和TransformedMap的漏洞触发点差别在于</p><p>TransformedMap是在写入元素的时候执行transform</p><p>我们上一个POC也看到了需要往Map中put才可以触发这个漏洞</p><p>而LazyMap是在get方法中执行的transform</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containskey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">          Object value=factory.transform(key);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AnnotationInvocationHandler的invoke方法调用了get</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727103705064.png" alt="image-20220727103705064"></p><h3 id="关于Java对象代理"><a href="#关于Java对象代理" class="headerlink" title="关于Java对象代理"></a>关于Java对象代理</h3><blockquote><p>知道了AnnotationInvocationHandler的invoke方法调用了get 想要调用就可以利用Java的对象代理</p></blockquote><p>想要实现类似于PHP中的__call魔术方法 需要用到 <strong>java.reflect.Proxy</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure><p>newProxyInstance的参数为</p><ul><li>ClassLoader 默认的就可以了</li><li>代理的对象集合</li><li>InvocationHandler接口的对象</li></ul><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727105310916.png" alt="image-20220727105310916"></p><p>写了一个 ExampleIn来实现InvocationHandler接口</p><p>然后这个类实现了invoke方法，当调用的方法是get的时候就打印 Hacked 然后写了一个ExampleA来调用这个类</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727105531668.png" alt="image-20220727105531668"></p><p>虽然将Map中放入了 key为1！和value为5！</p><p>但是最后的运行结果是 Hacked</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727105641882.png" alt="image-20220727105641882"></p><p>这里思路就明确了 只能说妙哇</p><p>我们将InvocationHandler用Proxy代理，在触发readObject的时候，调用任意方法就可以触发invoke方法</p><p>进而触发get方法</p><p>那么知道了LazyMap怎么利用，就写一下LazyMap的利用链子</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727111606348.png" alt="image-20220727111606348"></p><blockquote><p>但是很遗憾的事情是 LazyMap这个链子也是只适用于低版本，我还是弹不出来</p></blockquote><h3 id="关于CC6"><a href="#关于CC6" class="headerlink" title="关于CC6"></a>关于CC6</h3><blockquote><p>前面的TransformedMap和LazyMap都有一个问题</p><p>那就是适用于8u701之前的版本 而高版本的需要学习一下CC6这条链子</p></blockquote><p>因为AnnotationInvocationHandler的readObject的代码内容发生了一些变化</p><p>P牛给出的利用链是：</p><ul><li>ObjectInputStream-&gt;readObject()</li><li>HashMap-&gt;readObject()</li><li>HashMap-&gt;hash()</li><li>TiedMapEntry-&gt;hashCode()</li><li>TiedMapEntry-&gt;getValue() （重点</li><li>LazyMap-&gt;get()</li><li>ChainedTransformer-&gt;transform()</li><li>InvokerTransformer-&gt;transform()</li><li>Method-&gt;invoke()</li><li>Runtime-&gt;exec()</li></ul><p>从TiedMapEntry-&gt;getValue()之前的是之前没看过的</p><p>后面的就是LazyMap那一条链子的利用</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727152848829.png" alt="image-20220727152848829"></p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727152914436.png" alt="image-20220727152914436"></p><p>在TiedMapEntry类中的hashCode方法中触发了getValue方法</p><p>跟进一下就发现调用了 this.map.get方法</p><blockquote><p>那么已经一眼顶针了，只需要跟着hashCode方法往上找就行了</p></blockquote><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727153351738.png" alt="image-20220727153351738"></p><p>看到这里的HashMap，就是通过hash()来进行调用</p><p>在ysoserial中前面还有两条链子，但是P牛这边的方法更巧妙，直接通过HashMap的readObject就可以触发hash的调用了(简单的链子更方便我们理解</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727153806886.png" alt="image-20220727153806886"></p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727153832089.png" alt="image-20220727153832089"></p><p>在readObject中触发了hash(), <del><strong>但是hash()如何触发的TiedMapEntry类中的hashCode捏？？？没搞明白</strong></del></p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727154144788.png" alt="image-20220727154144788"></p><p>家人们真相了，我是呆逼</p>]]></content>
      
      
      
        <tags>
            
            <tag> java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信</title>
      <link href="/2022/07/21/%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/07/21/%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="通信传输线路共建共享技术规范"><a href="#通信传输线路共建共享技术规范" class="headerlink" title="通信传输线路共建共享技术规范"></a>通信传输线路共建共享技术规范</h2><ul><li>杆距  架空线路两相邻杆中心线之间的距离</li><li>吊线  通过电杆或其他支撑物，架设用于拖挂或捆绑架空光(电)缆的高强度线(多为镀锌钢绞线)</li><li>拉线 平稀线条张力、加强线路稳定性的装置。</li><li>安全系数 材料强度极限和 容许应力 比值</li><li>管道 由多(单)孔管、人孔或手孔所构成的用于敷设光、电缆的地下建筑物</li></ul><h3 id="杆路共建的要求"><a href="#杆路共建的要求" class="headerlink" title="杆路共建的要求"></a>杆路共建的要求</h3><p> <strong>符合设计规范的相关规定</strong> 考虑可架挂的光缆数量 根据经过地区的气象负荷区的条件和光缆负荷进行 <strong>设计</strong></p><p>满足各方需求 明确共建杆路的起讫点、杆路长度、杆路路由、光缆条数、光缆类型、芯数、光缆安装位置、主要材料筹备方式和工期安排</p><p>吊线分层 <strong>自上而下安装</strong></p><p>两条以上光缆吊线 上下两层吊线间距 需要大于等于0.4m</p><p>杆高 应该安装2层 or 3层 光缆吊线设置</p><h3 id="杆路共享的要求"><a href="#杆路共享的要求" class="headerlink" title="杆路共享的要求"></a>杆路共享的要求</h3><p>新修杆路路由走向上 or 顺路附近有杆路的时候 可以考虑共享杆路</p><p>选择共享杆路时，应选择其路由近捷、地形及环境较好、杆线路由固定、建筑质量良好、施工及维护方便的杆路，并应避免选择需要进行大量整治、改造的杆路。</p><p>选定在原有杆路上架挂光缆时，应复核杆路容量、建筑强度</p><p>不应对原杆路缆线的使用和运行产生影响 <strong>注意保护已有光缆</strong></p><h3 id="管道共建的要求"><a href="#管道共建的要求" class="headerlink" title="管道共建的要求"></a>管道共建的要求</h3><p>满足需求和管道网络的灵活</p><p>管道孔应该预先划分使用区域、预留区域、共享区域。</p><p>管群的组合型式统一确定 一次性铺设完成</p><p>管孔容量较大时，管道埋设进行调整</p><p>共建管道的时候 以管孔作为单位区分 采用不同颜色进行识别</p><h3 id="管道共享的要求"><a href="#管道共享的要求" class="headerlink" title="管道共享的要求"></a>管道共享的要求</h3><p>剩余管道子孔数大于2时，开放共享。小于等于2的时候，采用微管、微缆、纺织子管等技术</p><p>做好清理准备</p><p>不能对现有网造成影响</p><h3 id="管道共建共享的其他要求"><a href="#管道共建共享的其他要求" class="headerlink" title="管道共建共享的其他要求"></a>管道共建共享的其他要求</h3><p>管孔内径大的管材放在管群的下方和外侧，小的放在上方和内侧。</p><p>共建时，应该统一用同一种材质</p><p>共建的时候 采用共用 or 分设 两种方式</p><h3 id="光缆共建的要求"><a href="#光缆共建的要求" class="headerlink" title="光缆共建的要求"></a>光缆共建的要求</h3><p>长途线路网光缆、本地线路网光缆、接入网光缆宜共建。光缆共建原则上同一路由各方光缆应分开建设并有明显区分标志，也可采用同缆分纤的方式。</p><p>数量进行合理分配</p><p>共建直埋光缆时，各条光缆应该有明显的区分标志</p><p><strong>直埋光缆宜采用同沟平行敷设，不得重叠或交叉，特殊情况可调整敷设方式。</strong></p><p>海底光缆时宜采用共缆分纤的共建方式</p><p>管道光缆同沟同井敷设时，应错开光缆接头位置</p><p>直埋光缆同沟敷设时，光缆配盘应错开接头盒位置，监测标石应有明显区分标志</p><h3 id="光缆共享的要求"><a href="#光缆共享的要求" class="headerlink" title="光缆共享的要求"></a>光缆共享的要求</h3><p>12芯的光缆芯数以上，纤芯资源需要预留30%以上</p><p>光纤共享时，所有方需要提供光缆光纤测试和引接条件</p><h3 id="施工要求"><a href="#施工要求" class="headerlink" title="施工要求"></a>施工要求</h3><p>共享光缆线路需要在已有网络上进行施工，需要确认引接点，避免对运行的光缆网络造成影响</p><p>对隐蔽工程做出检查和记录，有完整的竣工资料</p><p>在机房进行施工的时候 需要做好防护准备</p><h3 id="验收要求"><a href="#验收要求" class="headerlink" title="验收要求"></a>验收要求</h3><p>共建共享技术需要进行专门验收</p><p>验收范围包括 器材、建筑、工艺、线路防护等</p><p>主建方组织验收工作 各方参与验收</p><h2 id="通信管道施工验收标准"><a href="#通信管道施工验收标准" class="headerlink" title="通信管道施工验收标准"></a>通信管道施工验收标准</h2><h3 id="器材检验"><a href="#器材检验" class="headerlink" title="器材检验"></a>器材检验</h3><mark class="hl-label blue">一般规定</mark>  所用的器材规格、程式和质量应该满足设计和技术的要求，对不合格的器材进行及时处理。<p>要做好检验记录，进场后的存放、保管、消防、安全等要满足技术要求</p><mark class="hl-label blue">水泥相关</mark>   **注意水泥的出厂日期和证明** 不能使用过期的水泥，不能使用受潮变质的水泥。<p>水泥出厂到使用的时间超过了三个月或者有变质迹象的都需要在使用前进行鉴定，判断是否能继续使用。</p><p>采用的水泥都是<mark class="hl-label pink">水泥标号为42.5号</mark> 的普通硅酸盐水泥。</p><p>还需要满足以下条件</p><blockquote><ol><li>初凝时间不早于45min，终凝时间不晚于600min</li><li>容重为1100 ~ 1300 kg&#x2F;m3</li></ol></blockquote><p><strong>不同规格</strong>的水泥不能混合堆放</p><mark class="hl-label blue">砂</mark>  最好使用平均粒径为0.35 ~ 0.5mm的天然中砂<ul><li>轻物质不应该超过1%</li><li>硫化物和硫酸盐 重量不得超过0.5%</li><li>含泥量 重量不得超过5%</li><li>不能含有树叶 草根 木屑 等杂物</li></ul><p>砂的 <strong>容重</strong> 在松散情况下为 1300 ~ 1500kg&#x2F;m3 在密实的状态下为 1600 ~ 1700 kg&#x2F;m3</p><mark class="hl-label blue">石子</mark>  应该使用人工碎石或者天然砾石，不能使用风化石<p>采用 5~32mm粒径的连续粒级石子，大小粒径配合使用</p><p>石料应该符合下列规定</p><ul><li>含泥量 重量占比不应该超过1.5%</li><li>针状、片状石粒 重量占比不应该超过25%</li><li>硫化物和硫酸含量 重量占比不应该超过1%</li><li>不能含有杂物</li></ul><p>容重为 1350~1600kg&#x2F;m3</p><mark class="hl-label blue">砖</mark>  应该使用一等机制普通烧结砖<ul><li>砖的外形完整，耐水性好</li><li>遇到水后强度不会降低</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 通信工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thinkphp代码审计</title>
      <link href="/2022/07/20/Thinkphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2022/07/20/Thinkphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Thinkphp在这次的国赛中遇到了两次了</p><p>而代码审计又是每次打比赛都会遇到的问题</p><p>所以准备狠狠的提升一下自己的代码审计能力，就从thinkPHP框架入手吧</p></blockquote><p>TP的目录结构如下</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220720170222466.png" alt="image-20220720170222466"></p><p><strong>thinkphp采用的是MVC的结构</strong> 所以还是比较容易看清楚源码的，主要是学习一下路由 引用方法 挖链子</p>]]></content>
      
      
      
        <tags>
            
            <tag> -代码审计 -web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始</title>
      <link href="/2022/07/20/%E5%BC%80%E5%A7%8B/"/>
      <url>/2022/07/20/%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来一开始是用的LNMP+Wordpress搭建的一个博客</p><p>使用的是Sakura主题，一开始还觉得很能够用，Sakura主题也比较的花里胡哨的。但是时间长了有一些弊端。</p><ul><li>wordpress对于更新文章并不是很友好，hexo更适合我一点</li><li>本质上是更喜欢偏向简约风格的博客的，一开始Wordpress丰富的功能迷惑了我的双眼，后面还是发现hexo简约的风格更得到我的偏爱</li><li>Wordpress需要服务器，虽然有服务器，但是能白嫖github搭建博客也是极为不错的</li><li>已经搭建了wordpress+lnmp，想再试一下搭建hexo的博客</li></ul><p><strong>综上所述</strong>，最后选择了搭建这个hexo博客，也会尽量在之后多多更新，全栈爷清水说过一句话：<mark class="hl-label blue">文章才是博客的重中之重，花里胡哨的失去了博客的本意</mark> </p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在此为了方便其他人对butterfly进行魔改，所以将我魔改的步骤放在了这里供大家参考，当然我魔改的步骤也是参考的网上大佬们的博客</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为了<mark class="hl-label pink">简约</mark> ，在这里去掉了一开始的首页图和页脚</p><p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220720161011473.png" alt="image-20220720161011473"></p><p>直接在butterfly的配置文件中修改 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disable_top_img: true</span><br></pre></td></tr></table></figure><p>这样就可以将首页图去掉了</p><p>然后参考<a href="https://www.antmoe.com/posts/7198453/">小康的博客</a>就可以实现和本博客一样的背景了</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>字体的修改参考<a href="https://yanchengxu.top/hexo-font-modification/#%E5%88%9B%E5%BB%BAcss/">这个博客</a>然后就可以成功的修改博客的字体了</p><h3 id="光标样式"><a href="#光标样式" class="headerlink" title="光标样式"></a>光标样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur</span>),</span><br><span class="line">        default;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/pointer.cur</span>),</span><br><span class="line">        default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码，粘贴到一个引用的css文件中就可以得到和我的博客一样的光标</p><h3 id="图标的改变"><a href="#图标的改变" class="headerlink" title="图标的改变"></a>图标的改变</h3><p>想要达到类似于<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220720163407244.png" alt="image-20220720163407244"></p><p>一样的效果，那么就可以在阿里云的图标库里面找到自己喜欢的，然后在配置文件中引用就可以了</p><h3 id="右侧滚动条"><a href="#右侧滚动条" class="headerlink" title="右侧滚动条"></a>右侧滚动条</h3><p>复制下面的代码到css文件里面，再引用</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* 滚动条 */</span></span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ::-webkit-scrollbar-track &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">73</span>, <span class="number">177</span>, <span class="number">245</span>, <span class="number">0.2</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ::-webkit-scrollbar-thumb &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>(</span><br><span class="line">      <span class="number">45deg</span>,</span><br><span class="line">      <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">25%</span>,</span><br><span class="line">      transparent <span class="number">25%</span>,</span><br><span class="line">      transparent <span class="number">50%</span>,</span><br><span class="line">      <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">50%</span>,</span><br><span class="line">      <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">75%</span>,</span><br><span class="line">      transparent <span class="number">75%</span>,</span><br><span class="line">      transparent</span><br><span class="line">    );</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ::-webkit-scrollbar-corner &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ::-moz-selection &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>差不多的修改就这些，还有一些细枝末节的修改已经忘了，但是这样也差不多能够用了，毕竟 <strong>简洁</strong> 才是博客的中心，一些花里胡哨的东西还需要自己去挖掘</p><blockquote><p>以后如果对博客进行了修改也会更新在这上面的</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
