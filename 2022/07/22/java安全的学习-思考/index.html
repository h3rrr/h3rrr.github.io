<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java安全的学习与思考 | H3RRRの小站</title><meta name="keywords" content="java安全"><meta name="author" content="H3RRR"><meta name="copyright" content="H3RRR"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文是通过P牛的Java安全漫谈的顺序来进行的整理和理解的 根据Java安全漫谈的内容来进行理解和学习的 当然只是我本人的理解，要想来点纯正的味就还是去P牛的知识星球看吧 P牛知识星球  反射p牛的安全漫谈里面有一句话 java安全可以从反序列化漏洞开始，而反序列化漏洞又是从反射开始说起。  所以要想学习java安全，需要先从反射开始学起。 对象可以通过反射来获取它的类，类可以通过反射拿到所有的">
<meta property="og:type" content="article">
<meta property="og:title" content="java安全的学习与思考">
<meta property="og:url" content="https://h3rrr.github.io/2022/07/22/java%E5%AE%89%E5%85%A8%E7%9A%84%E5%AD%A6%E4%B9%A0-%E6%80%9D%E8%80%83/index.html">
<meta property="og:site_name" content="H3RRRの小站">
<meta property="og:description" content="本文是通过P牛的Java安全漫谈的顺序来进行的整理和理解的 根据Java安全漫谈的内容来进行理解和学习的 当然只是我本人的理解，要想来点纯正的味就还是去P牛的知识星球看吧 P牛知识星球  反射p牛的安全漫谈里面有一句话 java安全可以从反序列化漏洞开始，而反序列化漏洞又是从反射开始说起。  所以要想学习java安全，需要先从反射开始学起。 对象可以通过反射来获取它的类，类可以通过反射拿到所有的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://test-1303933256.cos.ap-chongqing.myqcloud.com/图床/0FA2009F7AF689C92790BE22746EE758.png">
<meta property="article:published_time" content="2022-07-22T01:33:49.000Z">
<meta property="article:modified_time" content="2022-07-27T07:44:11.741Z">
<meta property="article:author" content="H3RRR">
<meta property="article:tag" content="java安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://test-1303933256.cos.ap-chongqing.myqcloud.com/图床/0FA2009F7AF689C92790BE22746EE758.png"><link rel="shortcut icon" href="/img/%E7%89%9B%E5%A5%B6.png"><link rel="canonical" href="https://h3rrr.github.io/2022/07/22/java%E5%AE%89%E5%85%A8%E7%9A%84%E5%AD%A6%E4%B9%A0-%E6%80%9D%E8%80%83/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java安全的学习与思考',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-27 15:44:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/CodeByZach/pace/themes/green/pace-theme-flash.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/font2.css"><link rel="stylesheet" href="/css/custom.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/dog1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About me</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">H3RRRの小站</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About me</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">java安全的学习与思考</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-22T01:33:49.000Z" title="发表于 2022-07-22 09:33:49">2022-07-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-27T07:44:11.741Z" title="更新于 2022-07-27 15:44:11">2022-07-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java安全的学习与思考"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>本文是通过P牛的Java安全漫谈的顺序来进行的整理和理解的 根据Java安全漫谈的内容来进行理解和学习的</p>
<p>当然只是我本人的理解，要想来点纯正的味就还是去P牛的知识星球看吧</p>
<p><a target="_blank" rel="noopener" href="https://wx.zsxq.com/dweb2/index/group/2212251881">P牛知识星球</a></p>
</blockquote>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>p牛的安全漫谈里面有一句话 <mark class="hl-label blue">java安全可以从反序列化漏洞开始，而反序列化漏洞又是从反射开始说起。</mark> </p>
<p>所以要想学习java安全，需要先从反射开始学起。</p>
<p><strong>对象可以通过反射来获取它的类，类可以通过反射拿到所有的方法，包括私有方法</strong> </p>
<p>在java中有三种方式来获取一个</p>
<mark class="hl-label Class.forName">obj.getClass()</mark>  这三种方法，最后一种其实不算是反射，另外两种，一种是通过实例的obj来获取类，一种是知道类的名字来获取类

<blockquote>
<p>使用反射可以合理的绕过沙盒</p>
</blockquote>
<p>比如在一个情景下，只有Integer类型的数字，那么怎么调用Runtime类？P牛给了一个例子（伪代码）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数字.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这就通过了获取数字的类，来通过 <strong>forName</strong> 方法调用 <strong>Runtime类对象</strong></p>
<h3 id="关于forName"><a href="#关于forName" class="headerlink" title="关于forName"></a>关于forName</h3><p>forName除了我们上面见到的通过类名字调用类的方法以外还有一种</p>
<mark class="hl-label name,">forName(String</mark>  当第二个参数等于true的时候和上面讲的forName是一样的

<p>第一个参数是类名 第二个参数是否初始化 第三个参数是类加载器 类加载器的作用是告诉JVM如何加载这个类</p>
<p> 可以通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>来通过类加载器获取到类对象</p>
<h3 id="无参构造函数的利用"><a href="#无参构造函数的利用" class="headerlink" title="无参构造函数的利用"></a>无参构造函数的利用</h3><blockquote>
<p>除了系统类 想要引用其他类需要import</p>
<p>但是 forName就不需要，可以加载任意类</p>
</blockquote>
<mark class="hl-label blue">class.newInstance()</mark> 可以调用类中的无参构造函数 但是有些情况是无法使用的

<ul>
<li>因为可能使用的类没有无参构造函数</li>
<li>构造函数是私有的（单例情况</li>
</ul>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220722113313745.png" alt="image-20220722113313745"></p>
<p>面对单例模式的时候，通过getMethod和invoke还是可以成功的弹出计算机的</p>
<blockquote>
<p>getMethod是通过反射获取一个类特定的公有方法</p>
<p>invoke是执行方法 正常的执行方法是 A.方法(1,2,3..)在反射中是 方法.invoke(1,2,3…)</p>
</blockquote>
<p>拆开来是这样的</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220722120008472.png" alt="image-20220722120008472"></p>
<h3 id="关于getConstructor"><a href="#关于getConstructor" class="headerlink" title="关于getConstructor"></a>关于getConstructor</h3><p>在无参构造函数中，可以发现如果一个类没有无参构造函数也不是单例模式或者构造方法是私有方法，就无法成功的反射</p>
<p><strong>这里引入的新反射方法就可以很好的解决上面的问题</strong></p>
<p>getConstructor的参数是构造函数列表类型</p>
<p>在获取到构造函数之后 可以使用newInstance来执行</p>
<p>P牛在这里将了除了Runtime外的另外一种执行命令的方式ProcessBuilder</p>
<p>这边通过其构造函数来调用star执行命令</p>
<blockquote>
<p>在这里普及一下 ProcessBuilder类和Runtime类的一些区别，就是Runtime类执行脚本的时候会弹出一个cmd界面 但是ProcessBuilder不会 它可以在 <strong>后台</strong> 运行</p>
</blockquote>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220722153544429.png" alt="image-20220722153544429"></p>
<p>在这里用到了强转，因为clazz是没有类型的，所以在这里直接强转一个类型，然后后面调用方法。</p>
<p>但是有的时候可能会不能使用强转 所以需要</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220722154218017.png" alt="image-20220722154218017"></p>
<p>通过 <strong>getMethod</strong> 方法来获取到star方法</p>
<p>ProcessBuilder有两种构造函数</p>
<ul>
<li>public ProcessBuilder(List<String> command)</li>
<li>public ProcessBuilder(String… command)</li>
</ul>
<p>前面展示的是第一种方法的调用</p>
<p>而第二种涉及java中的可变长参数 可以理解为数组</p>
<p>那么按照一样的思路写出来的payload因为newInstance和ProcessBuilder都接收的可变长参数，两者叠加为一个二维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">((ProcessBuilder)</span><br><span class="line">clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;&#125;)).start();</span><br></pre></td></tr></table></figure>

<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220722160714949.png" alt="image-20220722160714949"></p>
<p>不同强类型转化的话就是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz =Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;&#125; ));</span><br></pre></td></tr></table></figure>

<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220722160814866.png" alt="image-20220722160814866"></p>
<p>一样的思路</p>
<mark class="hl-label blue">但是现在只是解决了无参构造的问题，如果方法是私有的，那么应该怎么解决？</mark> 

<h3 id="关于getDeclared"><a href="#关于getDeclared" class="headerlink" title="关于getDeclared"></a>关于getDeclared</h3><p>与前面讲到的几种方法相比，有区别的地方是</p>
<ul>
<li>getMethod是获取的所有的公共方法</li>
<li>getDeclared获取的是类中声明的方法，公共方法和私有方法都可以获取</li>
</ul>
<p>在这里用Runtime这个类写一个payload</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz =Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; m = clazz.getDeclaredConstructor();</span><br><span class="line">m.setAccessible(<span class="literal">true</span>); <span class="comment">//这是必须的，在获取到私有方法后需要用这个方法来修改作用域</span></span><br><span class="line">clazz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class).invoke(m.newInstance(),<span class="string">&quot;calc.exe&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="关于反射"><a href="#关于反射" class="headerlink" title="关于反射"></a>关于反射</h3><p>其实java的反射机制 体现的就是一个 <strong>动态</strong> 的特点，只要知道了这个类的名称，就可以获取到这个类所有的属性和方法 包括了 <strong>私有方法</strong>。</p>
<h2 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h2><blockquote>
<p>RMI是让java虚拟机上的对象调用另外一个java虚拟机对象上的方法 而且是java独有的一种机制</p>
</blockquote>
<h3 id="关于RMI的流程"><a href="#关于RMI的流程" class="headerlink" title="关于RMI的流程"></a>关于RMI的流程</h3><p>平时我们调用方法是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">object1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>();</span><br><span class="line">object1.Method();</span><br></pre></td></tr></table></figure>

<p>但是如果object1在JVM1上，但是程序运行在JVM2上</p>
<p>这样如果想访问object1的方法，就需要调用RMI</p>
<p>RMI主要有三个部分</p>
<ul>
<li>RMI registry</li>
<li>RMI client</li>
<li>RMI server</li>
</ul>
<p>但是其实还涉及到了Stub Skeleton RPL，但是这里不讲这些也可以理解，可以去网上看看更详细的资料</p>
<p>对服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloInterface</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    &#125; <span class="comment">//继承Remote的接口 定义函数hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">HelloInterface</span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">HelloImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;欢迎来到黑暗米奇妙妙屋&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;┗|｀O′|┛ 嗷~~&quot;</span>;</span><br><span class="line">        &#125; <span class="comment">//实现接口的类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HelloImpl</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloImpl</span>();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);   Naming.rebind(<span class="string">&quot;rmi://127.0.0.1:1099/hello&quot;</span>,hello);</span><br><span class="line">    &#125;<span class="comment">//创建registry 将类的实例化绑定到一个地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RMIServer</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        RMIServer.<span class="type">HelloInterface</span> <span class="variable">hello</span> <span class="operator">=</span> (RMIServer.HelloInterface)</span><br><span class="line">               Naming.lookup(<span class="string">&quot;rmi://192.168.0.111:1099/hello&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> hello.hello();</span><br><span class="line">        System.out.println( ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Naming.lookup 在registry找到名字是hello的对象，然后就跟平时的使用一样。</p>
<p>启动客户端和服务端可以发现</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220725110959469.png" alt="image-20220725110959469"></p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220725111022141.png" alt="image-20220725111022141"></p>
<p>成功的调用到了 <strong>hello</strong> 函数</p>
<p>大概的流程就是这样</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/v2-6e06c5b9bbc9f60796e5d60ebd931eaf_720w.jpg" alt="img"></p>
<p>在上面 RMI server的代码中</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220725112239832.png" alt="image-20220725112239832"></p>
<p>可以换为</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220725112300147.png" alt="image-20220725112300147"></p>
<p>得到的结果是一样的，总的来说就是先创建并且运行RMI registry，然后再将HelloImpl对象绑定在hello上</p>
<h3 id="关于如何攻击RMI"><a href="#关于如何攻击RMI" class="headerlink" title="关于如何攻击RMI"></a>关于如何攻击RMI</h3><p>P牛提出了两个问题</p>
<blockquote>
<ul>
<li>如果能访问RMI registry的服务 如何利用？</li>
<li>如果RMI client中的Naming.lookup的第一个参数可控，如何利用？</li>
</ul>
</blockquote>
<p>首先 Java对远程访问RMI registry有限制</p>
<p>只有是本地访问的时候才可以调用下面几种方法</p>
<blockquote>
<ul>
<li>rebind</li>
<li>bind</li>
<li>unbind</li>
</ul>
</blockquote>
<p>但是list和lookup是可以远程调用的</p>
<p>list可以列出目标上绑定的所有对象</p>
<p>lookup可以获得某个远程对象</p>
<p><del>那么这里就可以通过写一些工具来对危险的方法进行探测</del></p>
<p>Nmap什么的还有Github上面一堆类似的项目 没啥意义</p>
<h3 id="关于codebase"><a href="#关于codebase" class="headerlink" title="关于codebase"></a>关于codebase</h3><p>codebase可以理解为我们平时看到的本地路径</p>
<p>会告诉JVM应该去哪个地方寻找类</p>
<p>比如 指定 codebase &#x3D; <a target="_blank" rel="noopener" href="http://2323bb.com/">http://2323bb.com</a></p>
<p>然后需要加载 org.h3rrr.example.Example类</p>
<p>那么JVM会下载  <a target="_blank" rel="noopener" href="http://2323bb.com/org/h3rrr/example/Example.class">http://2323bb.com/org/h3rrr/example/Example.class</a> 文件</p>
<p>如果在RMI流程中没有在本地找到需要的类就会加载codebase中的类</p>
<blockquote>
<p>那么就可以通过控制codebase来进行rce</p>
</blockquote>
<p>但是要满足上述条件需要</p>
<ul>
<li>安全配置SecurityManager</li>
<li>Java版本低 </li>
<li>设置了java.rmi.server.useCodebaseOnly&#x3D;false</li>
</ul>
<p><del><strong>那么如何通过codebase来进行利用呢？</strong> P牛在这里给了一个实例，来试一下</del></p>
<h3 id="关于攻击RMI"><a href="#关于攻击RMI" class="headerlink" title="关于攻击RMI"></a>关于攻击RMI</h3><blockquote>
<p>因为内容太多了 会一直进行更进学习的 慢慢更</p>
</blockquote>
<p>因为P牛其实在RMI讲的攻击算是只讲了一些，所以在其他地方查了一下相关的资料，准备好好的写一下RMI</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7930#toc-0">先知社区RMI攻击方式总结</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/263726#h2-3">同样是RMI攻击方式的总结，但是更好懂一点</a></p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/20200701101308-6810e0aa-bb40-1.png" alt="img"></p>
<p>大佬算是总结的很详细了，这个是大纲，差不多能看一下其实对RMI的攻击方法还是很多的</p>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><blockquote>
<p>在日常的CTF比赛中也经常出现反序列化的题目</p>
<p>虽然大部分都是PHP的反序列化</p>
</blockquote>
<p>Java和PHP的反序列化不一样的地方就是 Java可以对序列化数据中插入一些自定义的数据，在反序列化的时候能够通过 <strong>readObject</strong> 进行读取</p>
<p>反序列化中 <strong>writeObject</strong> 和 <strong>readObject</strong> 是十分 重要的两个函数</p>
<blockquote>
<p>这里有一个很经典的Java反序列化工具</p>
<p><a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial">ysoserial</a></p>
</blockquote>
<h3 id="关于URLDNS"><a href="#关于URLDNS" class="headerlink" title="关于URLDNS"></a>关于URLDNS</h3><p>P牛在这里说了从CC链开始学习Java反序列化是十分困难的</p>
<p>确实，我一开始也是从CC链入手，但是后面发现越来越看不懂，所以还是从URLDNS开始入手吧！</p>
<blockquote>
<p>那么根据ysoserial的payload来看一下URLDNS这个链子</p>
</blockquote>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726102228536.png" alt="image-20220726102228536"></p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726102252919.png" alt="image-20220726102252919"></p>
<p>可以看到HashMap，跟进一下</p>
<blockquote>
<p>因为之前说了触发反序列化的方法是 readObject，所以直接看到 HashMap -&gt; readObject()</p>
</blockquote>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726102523097.png" alt="image-20220726102523097"></p>
<p>可以看到这里对key进行了hash计算，跟进一下</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726102649202.png" alt="image-20220726102649202"></p>
<p>这里调用了key的hashCode方法，在这里的key是URL，所以跟进一下 java.net.URL的hashCode方法</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726102930545.png" alt="image-20220726102930545"></p>
<p>可以看到当hashCode为-1的时候会触发 <strong>handler.hashCode</strong> 跟进一下</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726103152356.png" alt="image-20220726103152356"></p>
<p>这里的handler是  URLStreamHandler 的对象 跟进一下</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726103703041.png" alt="image-20220726103703041"></p>
<p>发现了 <strong>getHostAddress</strong> 继续跟进一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (u.hostAddress != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> u.hostAddress;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> u.getHost();</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="literal">null</span> || host.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            u.hostAddress = InetAddress.getByName(host);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException se) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u.hostAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到触发了getByName()</p>
<p>所以整个链子的过程是</p>
<ol>
<li>HashMap-&gt;readObject()</li>
<li>HashMap-&gt;hash()</li>
<li>URL-&gt;hashCode()</li>
<li>URLStreamHandler-&gt;hashCode()</li>
<li>URLStreamHandler-&gt;getHostAddress()</li>
<li>InetAddress-&gt;getByName()</li>
</ol>
<p>根据这个链子来写一个EXP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先鸽一下 JDK版本太高了 写了跑不起我超</span><br></pre></td></tr></table></figure>

<h3 id="关于CommonCollections"><a href="#关于CommonCollections" class="headerlink" title="关于CommonCollections"></a>关于CommonCollections</h3><blockquote>
<p>躲不掉的CC链</p>
</blockquote>
<p>在这里P牛给了一个他简化的CC1的链子demo，然后在这个demo中有几个重要的 <strong>接口</strong> 和 <strong>类</strong> </p>
<p>{ % label Transformer blue %}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 TransformedMap转换Map新元素的时候会调用transform方法，类似于调用一个“回调函数”，参数是原始的对象</p>
<p>{ % label ConstantTransformer blue %}</p>
<p>是实现Transformer接口的一个类，就是在构造函数的时候传入一个对象 在transform方法将这个对象返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn&#123;</span></span><br><span class="line"><span class="params"> 	<span class="built_in">super</span>()</span>;</span><br><span class="line"> 	iConstant = constantToReturn; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line"> 	<span class="keyword">return</span> iConstant;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>作用就是包装一个对象，在执行回调的时候返回这个对象性，方便进行下一步的操作</p>
<p>{ % label InvokerTransformer red %}</p>
<p>也是实现Transformer接口的一个类，可以执行任意方法</p>
<p>是 <strong>反序列化能够执行任意代码的关键</strong></p>
<p>在实例化的时候需要传入三个参数</p>
<ul>
<li>执行的方法名字</li>
<li>函数的参数列表的参数类型</li>
<li>传给这个函数的参数列表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line"> 	<span class="built_in">super</span>();</span><br><span class="line"> 	iMethodName = methodName;</span><br><span class="line"> 	iParamTypes = paramTypes;</span><br><span class="line"> 	iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面回调的transform方法，就是执行input对象的methodName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line"> <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line"> <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> +</span><br><span class="line">iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> +</span><br><span class="line">iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> +</span><br><span class="line">iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>{ % label ChainedTransformer blue %}</p>
<p>也也也是实现了Transformer接口的一个类</p>
<p>可以将 内部多个 Transformer串联在一起 前一个回调的返回结果作为后一个回调的参数传入</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726152229772.png" alt="image-20220726152229772"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> &#123;</span><br><span class="line"> 	<span class="built_in">super</span>();</span><br><span class="line"> 	iTransformers = transformers; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line"> object = iTransformers[i].transform(object);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> object; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>{ % label TransformedMap blue %}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, keyTransformer,valueTransformer);</span><br></pre></td></tr></table></figure>

<p>然后来看一下P牛给的代码</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726153010072.png" alt="image-20220726153010072"></p>
<p>在前面创建了一个transformers，这里面包括了两个Transformer</p>
<ul>
<li>ConstantTransformer</li>
</ul>
<p>我们在上面才说道，ConstantTransformer的作用就是传入一个对象，在这里我们获取Runtime.getRuntime</p>
<ul>
<li>InvokerTransformer</li>
</ul>
<p>上面说过这个是 <strong>反序列化执行代码</strong> 的关键！！！在这里面写的是执行 弹计算器的操作 第一个参数写的exec是执行的方法名字 第二个是String的类型，就是exec的参数类型 第三个是传入给这个函数的参数，也就是calc.exe</p>
<p>然后利用</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726153618011.png" alt="image-20220726153618011"></p>
<p>将这一系列的 transformer串起来了 根据上面那个流程图来理解一下 但是这些只是一系列的回调，需要包innerMap</p>
<p>所以用TransformedMap的decorate方法</p>
<p>通过向Map中放入新的元素来触发回调</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220726154859030.png" alt="image-20220726154859030"></p>
<h3 id="关于TransformedMap"><a href="#关于TransformedMap" class="headerlink" title="关于TransformedMap"></a>关于TransformedMap</h3><blockquote>
<p>上面那个只能算是一个demo，还不算POC</p>
<p>md配环境太折磨了，就跟着P牛走一遍，我是不想配这个玩意了</p>
</blockquote>
<p>在demo中，通过向Map中加入一个新的元素来触发回调</p>
<p>但是在实际的反序列化的时候，需要找到一个类，类似于readObject有写入的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memberValue.setValue(<span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>( value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember( annotationType.members().get(name)));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map.Entry&lt;String,Object&gt;memberValue:memberValues.entrySet()</span><br></pre></td></tr></table></figure>

<p>主要的逻辑就是这两部分</p>
<p>在这里的memberValues就是反序列化后得到的Map 然后在后面调用了setValue来设置值，这样就可以触发TransformedMap里面的Transform执行恶意代码</p>
<p>所以POC需要创建AnnotationInvocationHandler的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,Map.class); construct.setAccessible(<span class="literal">true</span>); </span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> construct.newInstance(Retention.class, outerMap);</span><br></pre></td></tr></table></figure>

<p>可以看到这里通过了反射的方法来调用AnnotationInvocationHandler的构造方法</p>
<blockquote>
<p>是因为sun.reflect.annotation.AnnotationInvocationHandler是JDK内部类，不能直接new来实例化</p>
</blockquote>
<p>而AnnotationInvocationHandler的构造函数有两个参数，一个是Annotation类，另外一个是前面的Map</p>
<blockquote>
<p>在这里P牛问了什么是Annotation类 为什么要使用Retention.class？</p>
<p>在这里我理解为：Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明</p>
<ul>
<li>@Target</li>
<li>@Retention,</li>
<li>@Documented,</li>
<li>@Inherited</li>
</ul>
<p>所以是 Retention.class 不知道对不对</p>
</blockquote>
<p>前面构造了AnnotationInvocationHandler的对象，所以需要将这个对象序列化</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727093140160.png" alt="image-20220727093140160"></p>
<p>然后跟着P牛的代码敲了一下 在之前那个demo下面加了一些东西</p>
<p>运行发现报错</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727093227496.png" alt="image-20220727093227496"></p>
<p>是因为 不是所有的对象都支持序列化，<strong>待序列化对象和它全部的内部属性对象都必须要实现 java.io.Serializable接口</strong> </p>
<p>是因为在之前那个demo中传给ConstantTransformer的Runtime.getRuntime()，Runtime类是没有实现java.io.Serializable接口的，所以不能被 <strong>序列化</strong></p>
<p>而通过反射可以避免这个问题</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727094132662.png" alt="image-20220727094132662"></p>
<blockquote>
<p>我只能说 Java安全…博大精深 Transformer恐怖如斯</p>
</blockquote>
<p>因为将Runtime.getRuntime()换成了Runtime.class</p>
<p>因为前者是 Runtime的对象 后者是 Class对象</p>
<p>Class类是实现了java.io.Serializable接口的，所以可以序列化 再次运行就可以发现没有报错了 但是还是没有计算器弹出来</p>
<p>那是因为在readObject里面有一个逻辑判断，当var7不为null的时候才可以触发这个漏洞</p>
<p>关于如何解决这个问题 P牛也没细说 直接给了解决方案</p>
<ul>
<li>AnnotationInvocationHandler 构造函数的第一个参数必须要是Annotation的子类，并且必须要包含至少一个方法 在这里假设方法名是A</li>
<li>那么TransformedMap.decorate修饰的Map中必须有一个key为X的元素</li>
</ul>
<p>所以之前为啥要用Retention.class也解决了，因为有一个方法是value，再往Map里面放一个value的key</p>
<p>按照道理来说，应该是成功的弹出计算器了</p>
<p>但是！因为我们的JDK版本太高了，所以会没办法触发</p>
<p>只有在 8u71以前的版本才可以触发这个版本 因为官方修改了readObject函数 我的评价是寄！昨天配了很久的环境都不对劲，这里就不换环境了，差不多理解一下就行了</p>
<blockquote>
<p>高版本和低版本的readObjetc区别就是 没有使用反序列化得到的Map对象，是新建了一个LinkedHashMap对象 后面的操作都是基于LinkedHashMap这个新的对象进行操作了，所以构造的针对Map的操作就没有用了 SAD！！！</p>
</blockquote>
<p>在ysoserial中我们可以发现它是利用了LazyMap而不是TransformedMap</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727095956005.png" alt="image-20220727095956005"></p>
<h3 id="关于LazyMap"><a href="#关于LazyMap" class="headerlink" title="关于LazyMap"></a>关于LazyMap</h3><p>那么那么LazyMap是什么捏？</p>
<blockquote>
<p>与TransformedMap类似 来自于Common-Collections库</p>
<p>继承AbstractMapDecorator</p>
</blockquote>
<p>LazyMap和TransformedMap的漏洞触发点差别在于</p>
<p>TransformedMap是在写入元素的时候执行transform</p>
<p>我们上一个POC也看到了需要往Map中put才可以触发这个漏洞</p>
<p>而LazyMap是在get方法中执行的transform</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containskey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">          Object value=factory.transform(key);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>AnnotationInvocationHandler的invoke方法调用了get</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727103705064.png" alt="image-20220727103705064"></p>
<h3 id="关于Java对象代理"><a href="#关于Java对象代理" class="headerlink" title="关于Java对象代理"></a>关于Java对象代理</h3><blockquote>
<p>知道了AnnotationInvocationHandler的invoke方法调用了get 想要调用就可以利用Java的对象代理</p>
</blockquote>
<p>想要实现类似于PHP中的__call魔术方法 需要用到 <strong>java.reflect.Proxy</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure>

<p>newProxyInstance的参数为</p>
<ul>
<li>ClassLoader 默认的就可以了</li>
<li>代理的对象集合</li>
<li>InvocationHandler接口的对象</li>
</ul>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727105310916.png" alt="image-20220727105310916"></p>
<p>写了一个 ExampleIn来实现InvocationHandler接口</p>
<p>然后这个类实现了invoke方法，当调用的方法是get的时候就打印 Hacked 然后写了一个ExampleA来调用这个类</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727105531668.png" alt="image-20220727105531668"></p>
<p>虽然将Map中放入了 key为1！和value为5！</p>
<p>但是最后的运行结果是 Hacked</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727105641882.png" alt="image-20220727105641882"></p>
<p>这里思路就明确了 只能说妙哇</p>
<p>我们将InvocationHandler用Proxy代理，在触发readObject的时候，调用任意方法就可以触发invoke方法</p>
<p>进而触发get方法</p>
<p>那么知道了LazyMap怎么利用，就写一下LazyMap的利用链子</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727111606348.png" alt="image-20220727111606348"></p>
<blockquote>
<p>但是很遗憾的事情是 LazyMap这个链子也是只适用于低版本，我还是弹不出来</p>
</blockquote>
<h3 id="关于CC6"><a href="#关于CC6" class="headerlink" title="关于CC6"></a>关于CC6</h3><blockquote>
<p>前面的TransformedMap和LazyMap都有一个问题</p>
<p>那就是适用于8u701之前的版本 而高版本的需要学习一下CC6这条链子</p>
</blockquote>
<p>因为AnnotationInvocationHandler的readObject的代码内容发生了一些变化</p>
<p>P牛给出的利用链是：</p>
<ul>
<li>ObjectInputStream-&gt;readObject()</li>
<li>HashMap-&gt;readObject()</li>
<li>HashMap-&gt;hash()</li>
<li>TiedMapEntry-&gt;hashCode()</li>
<li>TiedMapEntry-&gt;getValue() （重点</li>
<li>LazyMap-&gt;get()</li>
<li>ChainedTransformer-&gt;transform()</li>
<li>InvokerTransformer-&gt;transform()</li>
<li>Method-&gt;invoke()</li>
<li>Runtime-&gt;exec()</li>
</ul>
<p>从TiedMapEntry-&gt;getValue()之前的是之前没看过的</p>
<p>后面的就是LazyMap那一条链子的利用</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727152848829.png" alt="image-20220727152848829"></p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727152914436.png" alt="image-20220727152914436"></p>
<p>在TiedMapEntry类中的hashCode方法中触发了getValue方法</p>
<p>跟进一下就发现调用了 this.map.get方法</p>
<blockquote>
<p>那么已经一眼顶针了，只需要跟着hashCode方法往上找就行了</p>
</blockquote>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727153351738.png" alt="image-20220727153351738"></p>
<p>看到这里的HashMap，就是通过hash()来进行调用</p>
<p>在ysoserial中前面还有两条链子，但是P牛这边的方法更巧妙，直接通过HashMap的readObject就可以触发hash的调用了(简单的链子更方便我们理解</p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727153806886.png" alt="image-20220727153806886"></p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727153832089.png" alt="image-20220727153832089"></p>
<p>在readObject中触发了hash(), <del><strong>但是hash()如何触发的TiedMapEntry类中的hashCode捏？？？没搞明白</strong></del></p>
<p><img src="https://test-1303933256.cos.ap-chongqing.myqcloud.com/%E5%9B%BE%E5%BA%8A/image-20220727154144788.png" alt="image-20220727154144788"></p>
<p>家人们真相了，我是呆逼</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://h3rrr.github.io">H3RRR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://h3rrr.github.io/2022/07/22/java%E5%AE%89%E5%85%A8%E7%9A%84%E5%AD%A6%E4%B9%A0-%E6%80%9D%E8%80%83/">https://h3rrr.github.io/2022/07/22/java安全的学习-思考/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://h3rrr.github.io" target="_blank">H3RRRの小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%AE%89%E5%85%A8/">java安全</a></div><div class="post_share"><div class="social-share" data-image="https://test-1303933256.cos.ap-chongqing.myqcloud.com/图床/0FA2009F7AF689C92790BE22746EE758.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/07/21/%E9%80%9A%E4%BF%A1/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">通信</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EforName"><span class="toc-number">1.1.</span> <span class="toc-text">关于forName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">无参构造函数的利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EgetConstructor"><span class="toc-number">1.3.</span> <span class="toc-text">关于getConstructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EgetDeclared"><span class="toc-number">1.4.</span> <span class="toc-text">关于getDeclared</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84"><span class="toc-number">1.5.</span> <span class="toc-text">关于反射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI"><span class="toc-number">2.</span> <span class="toc-text">RMI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ERMI%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">关于RMI的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%94%BB%E5%87%BBRMI"><span class="toc-number">2.2.</span> <span class="toc-text">关于如何攻击RMI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ecodebase"><span class="toc-number">2.3.</span> <span class="toc-text">关于codebase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%94%BB%E5%87%BBRMI"><span class="toc-number">2.4.</span> <span class="toc-text">关于攻击RMI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EURLDNS"><span class="toc-number">3.1.</span> <span class="toc-text">关于URLDNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ECommonCollections"><span class="toc-number">3.2.</span> <span class="toc-text">关于CommonCollections</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ETransformedMap"><span class="toc-number">3.3.</span> <span class="toc-text">关于TransformedMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ELazyMap"><span class="toc-number">3.4.</span> <span class="toc-text">关于LazyMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EJava%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">关于Java对象代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ECC6"><span class="toc-number">3.6.</span> <span class="toc-text">关于CC6</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/source/css/background.css')"><div id="footer-wrap"><div class="copyright">&copy;2022  <i id="heartbeat" class="fa fas fa-heartbeat"></i> H3RRR</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="/js/chocolate.js"></script><canvas id="universe"></canvas><script src="/js/sun_moon.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Jnylife/CDN@1.3/js/fish.js"></script><script defer src="/js/universe.js"></script><script defer src="https://cdn.jsdelivr.net/gh/CodeByZach/pace/pace.min.js"></script><div class="aplayer no-destroy" data-id="6798452235" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>